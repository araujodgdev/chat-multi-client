# Product Requirements Document (PRD)
## Sistema de Chat DistribuÃ­do com Salas de MÃºltiplos UsuÃ¡rios

---

### ğŸ“‹ InformaÃ§Ãµes do Documento

**VersÃ£o:** 1.0  
**Data:** Outubro 2025  
**Objetivo:** Trabalho AcadÃªmico - Sistemas DistribuÃ­dos  
**CritÃ©rios de AvaliaÃ§Ã£o:**
- Arquitetura DistribuÃ­da (4 pontos)
- ConcorrÃªncia/Paralelismo (2 pontos)
- DocumentaÃ§Ã£o/Artigo (4 pontos)

---

## 1. VisÃ£o Geral do Projeto

### 1.1 Objetivo
Desenvolver um sistema de chat distribuÃ­do que permita comunicaÃ§Ã£o em tempo real entre mÃºltiplos usuÃ¡rios organizados em salas, demonstrando conceitos de arquitetura distribuÃ­da, concorrÃªncia e paralelismo.

### 1.2 Escopo
Sistema cliente-servidor com suporte a mÃºltiplos clientes simultÃ¢neos, salas de chat, transferÃªncia de arquivos e recursos que explorem processamento concorrente e paralelo.

### 1.3 Justificativa AcadÃªmica
O projeto permite demonstrar:
- **Arquitetura DistribuÃ­da:** Modelo cliente-servidor com comunicaÃ§Ã£o via sockets
- **ConcorrÃªncia:** Gerenciamento de mÃºltiplas conexÃµes simultÃ¢neas
- **Paralelismo:** Processamento paralelo de tarefas (compressÃ£o, validaÃ§Ã£o, logs)
- **SincronizaÃ§Ã£o:** Controle de acesso a recursos compartilhados
- **ComunicaÃ§Ã£o:** Protocolos de mensagens estruturadas

---

## 2. Requisitos Funcionais

### RF01 - Servidor de Chat
**Prioridade:** Alta  
**DescriÃ§Ã£o:** O servidor deve gerenciar mÃºltiplas conexÃµes de clientes simultaneamente.

**CritÃ©rios de Aceite:**
- Suportar no mÃ­nimo 5 clientes simultÃ¢neos
- Usar threads ou processos para cada conexÃ£o
- Manter lista de clientes conectados
- Implementar heartbeat para detecÃ§Ã£o de desconexÃµes

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** Arquitetura DistribuÃ­da (1.0 pt)

---

### RF02 - Cliente de Chat
**Prioridade:** Alta  
**DescriÃ§Ã£o:** AplicaÃ§Ã£o cliente que conecta ao servidor e permite envio/recebimento de mensagens.

**CritÃ©rios de Aceite:**
- Interface simples (CLI ou GUI bÃ¡sica)
- Thread separada para recebimento de mensagens
- ReconexÃ£o automÃ¡tica em caso de falha
- Exibir status de conexÃ£o

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** Arquitetura DistribuÃ­da (0.5 pt)

---

### RF03 - Salas de Chat
**Prioridade:** Alta  
**DescriÃ§Ã£o:** Sistema de salas pÃºblicas e privadas para organizaÃ§Ã£o de conversas.

**CritÃ©rios de Aceite:**
- Sala pÃºblica padrÃ£o (todos os usuÃ¡rios)
- CriaÃ§Ã£o de salas privadas
- Listar salas disponÃ­veis
- Entrar/sair de salas
- Mensagens enviadas apenas para usuÃ¡rios da mesma sala

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** Arquitetura DistribuÃ­da (1.0 pt)

---

### RF04 - AutenticaÃ§Ã£o de UsuÃ¡rios
**Prioridade:** MÃ©dia  
**DescriÃ§Ã£o:** Sistema simples de autenticaÃ§Ã£o com nickname Ãºnico.

**CritÃ©rios de Aceite:**
- Nickname Ãºnico por sessÃ£o
- ValidaÃ§Ã£o de nickname duplicado
- Mensagem de boas-vindas personalizada

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** Arquitetura DistribuÃ­da (0.5 pt)

---

### RF05 - Broadcast de Mensagens
**Prioridade:** Alta  
**DescriÃ§Ã£o:** Envio de mensagens para todos os usuÃ¡rios de uma sala.

**CritÃ©rios de Aceite:**
- SincronizaÃ§Ã£o adequada (locks/semÃ¡foros)
- Timestamp em cada mensagem
- IdentificaÃ§Ã£o do remetente
- Broadcast assÃ­ncrono

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** ConcorrÃªncia/Paralelismo (0.5 pt), Arquitetura (0.5 pt)

---

### RF06 - TransferÃªncia de Arquivos
**Prioridade:** MÃ©dia  
**DescriÃ§Ã£o:** Envio de arquivos pequenos entre usuÃ¡rios com processamento paralelo.

**CritÃ©rios de Aceite:**
- Limite de tamanho (ex: 5MB)
- CompressÃ£o paralela usando Worker Thread antes do envio
- ValidaÃ§Ã£o de checksum
- Stream API para transferÃªncia eficiente
- Progress callback para acompanhamento

**ImplementaÃ§Ã£o Node.js:**
- Worker Thread dedicado para compressÃ£o (CPU-bound)
- Stream com pipeline para leitura/gravaÃ§Ã£o
- EventEmitter para progresso de transferÃªncia

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** ConcorrÃªncia/Paralelismo (0.8 pt), Arquitetura (0.5 pt)

---

### RF07 - Sistema de PresenÃ§a
**Prioridade:** MÃ©dia  
**DescriÃ§Ã£o:** Exibir status dos usuÃ¡rios (online, ausente, offline).

**CritÃ©rios de Aceite:**
- Lista de usuÃ¡rios online
- NotificaÃ§Ã£o de entrada/saÃ­da
- Thread de heartbeat
- Timeout configurÃ¡vel

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** ConcorrÃªncia/Paralelismo (0.3 pt)

---

### RF08 - Log AssÃ­ncrono
**Prioridade:** Baixa  
**DescriÃ§Ã£o:** Sistema de logging com gravaÃ§Ã£o assÃ­ncrona em arquivo.

**CritÃ©rios de Aceite:**
- Thread separada para I/O de logs
- Fila thread-safe para mensagens de log
- Registro de todas as operaÃ§Ãµes principais
- RotaÃ§Ã£o de logs por tamanho

**RelaÃ§Ã£o com AvaliaÃ§Ã£o:** ConcorrÃªncia/Paralelismo (0.4 pt)

---

## 3. Requisitos NÃ£o-Funcionais

### RNF01 - Performance
- LatÃªncia mÃ¡xima de 100ms para mensagens de texto
- Suportar 10 mensagens/segundo por sala
- Uso de memÃ³ria â‰¤ 200MB por cliente

### RNF02 - Escalabilidade
- Arquitetura preparada para adicionar mais servidores
- Pool de threads configurÃ¡vel
- Documentar limitaÃ§Ãµes de escala

### RNF03 - Confiabilidade
- ReconexÃ£o automÃ¡tica do cliente
- Tratamento de exceÃ§Ãµes adequado
- Graceful shutdown do servidor

### RNF04 - Reprodutibilidade
- CÃ³digo bem documentado
- README com instruÃ§Ãµes de instalaÃ§Ã£o/execuÃ§Ã£o
- DependÃªncias explÃ­citas
- Scripts de inicializaÃ§Ã£o

### RNF05 - Testabilidade
- Testes de carga bÃ¡sicos
- SimulaÃ§Ã£o de mÃºltiplos clientes
- Logs para debugging
- MÃ©tricas de performance

---

## 4. Arquitetura TÃ©cnica

### 4.1 VisÃ£o Geral
**PadrÃ£o:** Cliente-Servidor  
**ComunicaÃ§Ã£o:** TCP Sockets / WebSockets  
**Protocolo:** JSON sobre TCP  
**ConcorrÃªncia:** Event Loop + Worker Threads + Cluster API  
**Linguagem:** Node.js (JavaScript/TypeScript)

### 4.2 Componentes Principais

#### Servidor
```
Server (Master Process)
â”œâ”€â”€ Cluster Manager (fork mÃºltiplos workers)
â”‚   â””â”€â”€ Worker Process[]
â”œâ”€â”€ ConnectionManager (EventEmitter)
â”‚   â”œâ”€â”€ ClientHandler (socket por cliente)
â”‚   â””â”€â”€ HeartbeatMonitor (setInterval)
â”œâ”€â”€ RoomManager (Map thread-safe)
â”‚   â””â”€â”€ Room[] (Set de sockets)
â”œâ”€â”€ MessageBroker (EventEmitter + Queue)
â”œâ”€â”€ FileProcessor (Worker Threads)
â”‚   â””â”€â”€ CompressionWorker
â””â”€â”€ LogWriter (Worker Thread + Stream)
```

#### Cliente
```
Client (Single Process)
â”œâ”€â”€ ConnectionHandler (net.Socket/WebSocket)
â”œâ”€â”€ MessageReceiver (EventEmitter)
â”œâ”€â”€ UIController (readline/blessed)
â”œâ”€â”€ FileTransferManager (Worker Thread)
â””â”€â”€ ReconnectionHandler (exponential backoff)
```

### 4.3 Protocolo de Mensagens

```json
{
  "type": "MESSAGE|JOIN|LEAVE|FILE|HEARTBEAT",
  "sender": "nickname",
  "room": "room_name",
  "content": "...",
  "timestamp": "ISO8601",
  "metadata": {}
}
```

---

## 5. Conceitos de ConcorrÃªncia/Paralelismo Aplicados (Node.js)

### Event Loop (ConcorrÃªncia)
- **Main Thread:** Gerencia I/O nÃ£o-bloqueante via event loop
- **Callbacks/Promises:** OperaÃ§Ãµes assÃ­ncronas (conexÃµes, mensagens)
- **EventEmitter:** ComunicaÃ§Ã£o entre componentes via eventos

### Worker Threads (Paralelismo Real)
- **File Compression:** Worker dedicado para compressÃ£o CPU-intensiva
- **Checksum Validation:** CÃ¡lculo paralelo de hashes
- **Log Processing:** Worker para escrita assÃ­ncrona em disco
- **Thread Pool:** Gerenciamento de mÃºltiplos workers

### Cluster API (Multi-Processo)
- **Master Process:** Coordena workers e distribui conexÃµes
- **Worker Processes:** MÃºltiplas instÃ¢ncias do servidor (1 por CPU core)
- **IPC (Inter-Process Communication):** Mensagens entre master e workers
- **Load Balancing:** Round-robin automÃ¡tico entre workers

### SincronizaÃ§Ã£o
- **Atomic Operations:** SharedArrayBuffer para contadores globais
- **EventEmitter:** CoordenaÃ§Ã£o via eventos
- **Promises/async-await:** Controle de fluxo assÃ­ncrono
- **Semaphore Pattern:** Limitar conexÃµes simultÃ¢neas

### OperaÃ§Ãµes AssÃ­ncronas
- **Non-blocking I/O:** Socket connections via event loop
- **Stream API:** TransferÃªncia de arquivos com backpressure
- **Promise.all():** Broadcast paralelo para mÃºltiplos clientes
- **AsyncIterator:** Processamento de filas de mensagens

### DemonstraÃ§Ã£o PrÃ¡tica dos Conceitos
```javascript
// Exemplo de estrutura no servidor:
const cluster = require('cluster');
const { Worker } = require('worker_threads');

// 1. MULTI-PROCESSO (Cluster)
if (cluster.isMaster) {
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork(); // Processos paralelos
  }
}

// 2. CONCORRÃŠNCIA (Event Loop)
server.on('connection', async (socket) => {
  // Non-blocking I/O
  socket.on('data', handleMessage);
});

// 3. PARALELISMO (Worker Threads)
function compressFile(file) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./compression-worker.js');
    worker.postMessage(file);
    worker.on('message', resolve);
  });
}

// 4. SINCRONIZAÃ‡ÃƒO (Broadcast com Promise.all)
async function broadcastToRoom(room, message) {
  const clients = roomManager.getClients(room);
  await Promise.all(
    clients.map(client => sendMessage(client, message))
  );
}
```

---

## 6. Estrutura do Projeto Node.js

### 6.1 Estrutura de DiretÃ³rios
```
chat-distribuido/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ client/
â”‚   â”‚   â”œâ”€â”€ connection.ts         # Cliente WebSocket com reconexÃ£o
â”‚   â”‚   â”œâ”€â”€ file-transfer.ts      # Upload via streams e chunks
â”‚   â”‚   â”œâ”€â”€ index.ts              # Bootstrap CLI
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â””â”€â”€ cli.ts            # Interface de linha de comando
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â”œâ”€â”€ cluster-manager.ts    # OrquestraÃ§Ã£o via Cluster API
â”‚   â”‚   â”œâ”€â”€ connection-manager.ts # SessÃµes, heartbeat, presenÃ§a
â”‚   â”‚   â”œâ”€â”€ file-processor.ts     # Pool de workers para compressÃ£o
â”‚   â”‚   â”œâ”€â”€ index.ts              # Entry point HTTP/WebSocket
â”‚   â”‚   â”œâ”€â”€ message-broker.ts     # Broadcast assÃ­ncrono
â”‚   â”‚   â”œâ”€â”€ room-manager.ts       # Salas pÃºblicas/privadas
â”‚   â”‚   â”œâ”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.ts         # Logger Winston
â”‚   â”‚   â”‚   â””â”€â”€ serialization-queue.ts
â”‚   â”‚   â””â”€â”€ workers/
â”‚   â”‚       â”œâ”€â”€ compression-worker.ts
â”‚   â”‚       â””â”€â”€ log-worker.ts
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ config.ts             # Carregamento de variÃ¡veis de ambiente
â”‚       â”œâ”€â”€ constants.ts
â”‚       â”œâ”€â”€ index.ts
â”‚       â”œâ”€â”€ message-types.ts
â”‚       â”œâ”€â”€ protocol.ts           # SerializaÃ§Ã£o/validaÃ§Ã£o JSON
â”‚       â””â”€â”€ rooms.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ client.test.ts
â”‚   â”œâ”€â”€ load-test.ts
â”‚   â””â”€â”€ server.test.ts
â”œâ”€â”€ artillery.yml                 # CenÃ¡rio de carga WebSocket
â”œâ”€â”€ jest.config.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ package.json
â”œâ”€â”€ .env.example
â”œâ”€â”€ .eslintrc.cjs
â”œâ”€â”€ .gitignore
â”œâ”€â”€ logs/
â”‚   â””â”€â”€ .gitkeep
â””â”€â”€ README.md
```

### 6.2 package.json
```json
{
  "name": "chat-distribuido",
  "version": "1.0.0",
  "description": "Sistema de chat distribuÃ­do com mÃºltiplos clientes e salas",
  "type": "module",
  "private": true,
  "main": "dist/server/index.js",
  "exports": {
    "./server": "./dist/server/index.js",
    "./client": "./dist/client/index.js"
  },
  "scripts": {
    "build": "tsc --project tsconfig.json",
    "clean": "rimraf dist",
    "start:server": "node dist/server/index.js",
    "start:client": "node dist/client/index.js",
    "dev:server": "tsx watch src/server/index.ts",
    "dev:client": "tsx src/client/index.ts",
    "dev:client:watch": "tsx watch src/client/index.ts",
    "cluster": "node dist/server/cluster-manager.js",
    "lint": "eslint src --ext .ts",
    "test": "jest",
    "test:load": "artillery run artillery.yml"
  },
  "dependencies": {
    "blessed": "^0.1.81",
    "blessed-contrib": "^4.11.0",
    "chalk": "^5.3.0",
    "dotenv": "^16.3.1",
    "uuid": "^9.0.1",
    "winston": "^3.11.0",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/ws": "^8.5.8",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "artillery": "^2.0.0",
    "eslint": "^8.54.0",
    "jest": "^29.7.0",
    "rimraf": "^5.0.5",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "tsx": "^4.7.0",
    "typescript": "^5.3.2"
  },
  "engines": {
    "node": ">=18.18.0"
  }
}
```

### 6.3 VariÃ¡veis de Ambiente (.env)
```bash
# Servidor
SERVER_HOST=0.0.0.0
SERVER_PORT=9090
MAX_CONNECTIONS=100
HEARTBEAT_INTERVAL=30000
HEARTBEAT_TIMEOUT=45000

# Cluster
CLUSTER_WORKERS=auto  # 'auto' = nÃºmero de CPUs

# Worker Threads
COMPRESSION_WORKERS=2
LOG_WORKER_QUEUE_SIZE=1000

# Arquivos
MAX_FILE_SIZE=5242880  # 5MB em bytes
ALLOWED_FILE_TYPES=.txt,.pdf,.jpg,.png,.zip

# Logs
LOG_LEVEL=info
LOG_FILE=./logs/chat.log
LOG_MAX_SIZE=10485760  # 10MB
```

### 6.4 Comandos de ExecuÃ§Ã£o

#### Desenvolvimento (Modo Single Process)
```bash
# Terminal 1 - Servidor
npm run dev:server

# Terminal 2, 3, 4... - Clientes
npm run dev:client

# Opcional: CLI com auto-reload (reinicia a cada alteraÃ§Ã£o)
npm run dev:client:watch
```

#### ProduÃ§Ã£o (Modo Cluster)
```bash
# Servidor com cluster (mÃºltiplos processos)
npm run cluster

# Ou com PM2 (recomendado)
pm2 start src/server/cluster-manager.js -i max
pm2 monit
```

#### Testes
```bash
# Build de TypeScript (necessÃ¡rio antes dos scripts start:*)
npm run build

# Testes unitÃ¡rios
npm test

# Teste de carga (mÃºltiplos clientes simultÃ¢neos)
npm run test:load
```

### 6.5 Estado Atual da ImplementaÃ§Ã£o (Outubro/2025)
- **ConcluÃ­do:** estrutura TypeScript com build para `dist/`, servidor WebSocket (heartbeat, presenÃ§a, salas, broadcast, cluster stub), cliente CLI com reconexÃ£o e comandos de sala, carregamento de configuraÃ§Ã£o via `.env`, log estruturado com Winston, script de carga Artillery.
- **Em andamento:** integraÃ§Ã£o dos workers de compressÃ£o/log ao fluxo de transferÃªncia, ampliaÃ§Ã£o de testes automatizados, tratamento completo de upload/download no servidor, documentaÃ§Ã£o README.
- **Pendentes:** interface TUI (blessed), mÃ©tricas e dashboards, testes de carga com relatÃ³rios, artigo acadÃªmico e diagramas finais.

---

## 7. Tecnologias Sugeridas

### Tecnologia Escolhida: Node.js

**Justificativa:**
- Event-driven architecture (ideal para I/O intensivo)
- JavaScript tanto no servidor quanto no cliente
- NPM com vasto ecossistema
- Async/await nativo para cÃ³digo limpo
- Worker threads e cluster para paralelismo

**Stack TecnolÃ³gico:**
```
Backend (Servidor):
- net / ws (comunicaÃ§Ã£o TCP/WebSocket)
- worker_threads (paralelismo real)
- cluster (mÃºltiplos processos)
- events (EventEmitter)
- zlib (compressÃ£o)
- uuid (identificadores Ãºnicos)
- winston (logging assÃ­ncrono)

Frontend (Cliente):
- ws (cliente WebSocket)
- readline/promises + chalk (CLI)
- blessed/blessed-contrib (TUI avanÃ§ada - pendente)
- electron (opcional: GUI desktop)

DevOps:
- tsx (desenvolvimento com reload)
- eslint + @typescript-eslint (qualidade de cÃ³digo)
- jest/ts-jest (testes)
- artillery (testes de carga)
- pm2 (produÃ§Ã£o/cluster)
```

---

## 8. Plano de Desenvolvimento

### Fase 1 - FundaÃ§Ã£o 
- [x] Setup do ambiente Node.js (v18+)
- [x] Estrutura do projeto (src, tests, logs)
- [x] package.json com scripts e dependÃªncias
- [x] Estrutura bÃ¡sica cliente-servidor
- [x] ConexÃ£o TCP/WebSocket funcional
- [x] EventEmitter para gerenciamento de eventos
- [x] Mensagem simples texto
- [ ] README bÃ¡sico

### Fase 2 - ConcorrÃªncia 
- [x] Sistema de salas (RoomManager)
- [x] Broadcast sincronizado via Promise.all()
- [x] Heartbeat com setInterval e reconexÃ£o
- [x] MÃºltiplas conexÃµes simultÃ¢neas (event loop)
- [x] Winston para logging estruturado
- [ ] Testes bÃ¡sicos com Jest

### Fase 3 - Paralelismo
- [ ] TransferÃªncia de arquivos com Streams
- [ ] Worker Thread para compressÃ£o (zlib)
- [ ] Worker Thread para log assÃ­ncrono
- [x] Cluster API (mÃºltiplos processos)
- [x] Testes de carga com Artillery
- [ ] MÃ©tricas de performance (latÃªncia, throughput)

### Fase 4 - DocumentaÃ§Ã£o
- [ ] Coleta de mÃ©tricas
- [ ] Screenshots/diagramas
- [ ] RedaÃ§Ã£o do artigo
- [ ] RevisÃ£o final

---

## 9. Estrutura do Artigo (Deliverable)

### Estrutura ObrigatÃ³ria
1. **TÃ­tulo**
2. **Resumo** (150-250 palavras)
3. **IntroduÃ§Ã£o**
   - Contexto
   - MotivaÃ§Ã£o
   - Objetivos
4. **Metodologia**
   - Arquitetura escolhida
   - Tecnologias utilizadas
   - Conceitos aplicados
5. **Resultados**
   - Prints da aplicaÃ§Ã£o
   - Testes de concorrÃªncia
   - MÃ©tricas de performance
   - Diagramas de arquitetura
6. **ConclusÃ£o**
   - Objetivos alcanÃ§ados
   - Desafios enfrentados
   - Trabalhos futuros
7. **ReferÃªncias**

### Diagramas NecessÃ¡rios
- Arquitetura geral (cliente-servidor)
- Diagrama de threads
- Fluxo de mensagens
- Protocolo de comunicaÃ§Ã£o
- Diagrama de classes (opcional)

---

## 10. MÃ©tricas de Sucesso

### TÃ©cnicas
- âœ… Suportar 5+ clientes simultÃ¢neos
- âœ… LatÃªncia < 100ms
- âœ… 0 deadlocks em testes de 10 minutos
- âœ… 100% de mensagens entregues em condiÃ§Ãµes normais

### AcadÃªmicas
- âœ… Demonstrar claramente arquitetura distribuÃ­da
- âœ… Aplicar 3+ conceitos de concorrÃªncia
- âœ… DocumentaÃ§Ã£o completa e clara
- âœ… CÃ³digo reproduzÃ­vel e testado

---

## 11. Riscos e MitigaÃ§Ãµes

| Risco | Probabilidade | Impacto | MitigaÃ§Ã£o |
|-------|---------------|---------|-----------|
| Callback hell / Promises complexas | MÃ©dia | MÃ©dio | Usar async/await, ESLint, code review |
| Race conditions em event loop | Alta | MÃ©dio | Testes extensivos, usar EventEmitter corretamente |
| Bloqueio do event loop | MÃ©dia | Alto | Mover operaÃ§Ãµes CPU-bound para Worker Threads |
| Complexidade excessiva | MÃ©dia | MÃ©dio | MVP primeiro, features incrementais |
| Tempo insuficiente | Alta | Alto | Priorizar RF de alta prioridade |
| Gerenciamento de Worker Threads | MÃ©dia | MÃ©dio | DocumentaÃ§Ã£o clara, pool de workers fixo |

---

## 12. EntregÃ¡veis Finais

### CÃ³digo
- [ ] RepositÃ³rio GitHub pÃºblico ou .zip
- [ ] README.md completo
- [ ] CÃ³digo comentado (JSDoc)
- [x] package.json com dependÃªncias
- [x] .env.example para configuraÃ§Ãµes
- [x] Scripts npm (start, test, dev)

### DocumentaÃ§Ã£o
- [ ] Artigo em PDF (formato ABNT ou IEEE)
- [ ] MÃ­nimo 8 pÃ¡ginas, mÃ¡ximo 15
- [ ] Diagramas em alta resoluÃ§Ã£o
- [ ] Screenshots da aplicaÃ§Ã£o funcionando

### Testes
- [x] Script de teste de carga
- [ ] EvidÃªncias de mÃºltiplos clientes
- [ ] Logs de execuÃ§Ã£o

---

## 13. Checklist de AvaliaÃ§Ã£o

### Arquitetura DistribuÃ­da (4 pts)
- [x] ImplementaÃ§Ã£o cliente-servidor funcional (1.0)
- [x] Sistema de salas distribuÃ­do (1.0)
- [x] Protocolo de comunicaÃ§Ã£o estruturado (0.5)
- [ ] MÃºltiplos clientes simultÃ¢neos (0.5)
- [x] Gerenciamento de conexÃµes (0.5)
- [ ] DocumentaÃ§Ã£o da arquitetura (0.5)

### ConcorrÃªncia/Paralelismo (2 pts)
- [ ] Threads para mÃºltiplas conexÃµes (0.5)
- [ ] SincronizaÃ§Ã£o adequada (locks/semÃ¡foros) (0.5)
- [ ] Processamento paralelo (compressÃ£o/broadcast) (0.5)
- [ ] ComunicaÃ§Ã£o inter-threads (queues) (0.3)
- [ ] Thread assÃ­ncrona (logs/heartbeat) (0.2)

### Documento/Artigo (4 pts)
- [ ] Estrutura completa conforme solicitado (1.0)
- [ ] Diagramas de arquitetura claros (1.0)
- [ ] Resultados bem documentados (1.0)
- [ ] Metodologia detalhada (0.5)
- [ ] FormataÃ§Ã£o acadÃªmica adequada (0.5)
